namespace cooklang {
   [Throws=CooklangError]
   Recipe parse([ByRef] string input, [ByRef] string recipe_name);
};

//[Custom]
//typedef usize usize;

[Error]
enum CooklangError {
"Parser",
"Analysis",
"Io",
"NoFilename",
};


dictionary Recipe {
/// Recipe name
  string name;
/// Metadata
  Metadata metadata;
/// Each of the sections
///
/// If no sections declared, a section without name
/// is the default.
  sequence<Section> sections;
/// All the ingredients
  sequence<Ingredient> ingredients;
/// All the cookware
  sequence<Cookware> cookware;
/// All the timers
  sequence<Timer> timers;
/// All the inline quantities
  sequence<Quantity> inline_quantities;
//    pub(crate) data: D,
};

dictionary Metadata {};
dictionary Section {
  string? name;
  sequence<Step> steps;
};
dictionary Ingredient {
  /// Name
  ///
  /// This can have the form of a path if the ingredient references a recipe.
  string name;
  /// Alias
  string? alias;
  /// Quantity
  Quantity? quantity;
  /// Note
  string? note;
};
dictionary Cookware {
  /// Name
  ///
  /// This can have the form of a path if the ingredient references a recipe.
  string name;
  /// Alias
  string? alias;
  /// Quantity
  QuantityValue? quantity;
  /// Note
  string? note;
};
dictionary Timer {
  /// Name
  ///
  /// This can have the form of a path if the ingredient references a recipe.
  string? name;
  /// Quantity
  Quantity? quantity;
};

[Enum]
interface Item {
  Text(string value);
  ItemComponent(Component value);
  InlineQuantity(usize value);
};

[Enum]
interface QuantityValue {
  Fixed(Value value);
  Linear(Value value);
  ByServings(sequence<Value> values);
};

[Enum]
interface Value {
  Number(f64 value);
  //        bullshit
  Range(RangeInclusiveFloat value);
  //        bullshit
  Text(string value);
};

dictionary QuantityUnit {
  string text;
};

dictionary Step {
  sequence<Item> items;
  boolean is_text;
};

dictionary Quantity {
  QuantityValue value;
  QuantityUnit? unit;
};

enum ComponentKind {
  "IngredientKind",
  "CookwareKind",
  "TimerKind",
};

dictionary Component {
  ComponentKind kind;
  usize index;
};

dictionary RangeInclusiveFloat {};